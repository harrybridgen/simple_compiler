# build reactive framebuffer #
func framebuffer() {
    y = 0;
    dy ::= y + 1;

    loop {
        if y >= height { break; }

        screen[y] = [width];

        x = 0;
        dx ::= x + 1;

        loop {
            if x >= width { break; }

            yy := y;
            xx := x;

            screen[yy][xx] ::= (yy == ty && xx >= tx && xx < tx + text_len)
                             ? text[xx - tx]
                             : (' ');
            x = dx;
        }
        y = dy;
    }
}

# render (pure observation) #
func render() {
    print clear_terminal;
    print reset_cursor;

    y = 0;
    dy ::= y + 1;

    loop {
        if y >= height { break; }

        x = 0;
        dx ::= x + 1;

        loop {
            if x >= width { break; }
            print screen[y][x];
            x = dx;
        }

        println ' ';
        y = dy;
    }
}

# delay #
func delay(n) {
    d = 0;
    dd ::= d + 1;
    loop {
        if d >= n { break; }
        d = dd;
    }
}

# ================== MAIN ================== # 

# screen constants #
width := 31;
height := 5;
screen := [height];

# text constants #
text := "HELLO REACTIVE";
text_len := text;

# ESC CLI commands # 
clear_terminal := "\033[2J"
reset_cursor := "\033[H"

# horizontal motion #
tx = 0;
vx = 1;
dtx ::= tx + vx;

# vertical motion #
ty = 0;
vy = 1;
dty ::= ty + vy;


# build the reactive framebuffer #
framebuffer();

# main loop (advance time only) #
loop {
    render();
    delay(10000);

    tx = dtx;
    ty = dty;
    
    if tx < 0 {
        tx = -tx;
        vx = -vx;
    }

    if tx + text_len > width {
        tx = (width - text_len) - ((tx + text_len) - width);
        vx = -vx;
    }


    if ty < 0 {
        ty = -ty;
        vy = -vy;
    }

    if ty > height - 1 {
        ty = (height - 1) - (ty - (height - 1));
        vy = -vy;
    }
}