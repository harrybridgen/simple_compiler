# ---- pair of vectors ---- #
struct VecPair {
    A;
    B;
}


# ---- vec2 ---- #
struct Vec2 {
    x = 0;
    y = 0;
}

# ---- allocate vector arrays ---- #
func allocvecarrays(n) {
    P := struct VecPair;

    P.A = [n];
    P.B = [n];

    i = 0;
    di ::= i + 1;
    loop {
        if i >= n {
            break;
        }
        P.A[i] = struct Vec2;
        P.B[i] = struct Vec2;
        i = di;
    }

    return P;
}


# ---- init vectors ---- #
func initvectors(P) {
    A = P.A;
    B = P.B;

    A[0].x = 1;   A[0].y = 2;
    A[1].x = 3;   A[1].y = 4;
    A[2].x = 5;   A[2].y = 6;

    B[0].x = 7;   B[0].y = 8;
    B[1].x = 9;   B[1].y = 10;
    B[2].x = 11;  B[2].y = 12;
}


# ---- allocate matrix ---- #
func allocmatrix(A, B) {
    D := [A];

    i = 0;
    di ::= i + 1;
    loop {
        if i >= D {
            break;
        }
        D[i] = [B];
        i = di;
    }

    return D;
}

# ---- bind reactive dot products ---- #
func binddots(D, A, B) {
    i = 0;
    di ::= i + 1;

    loop {
        if i >= A {
            break;
        }

        j = 0;
        dj ::= j + 1;

        loop {
            if j >= B {
                break;
            }

            ii := i;
            jj := j;

            D[ii][jj] ::= A[ii].x*B[jj].x + A[ii].y*B[jj].y;

            j = dj;
        }

        i = di;
    }
}


# ---- print matrix ---- #
func printmatrix(D) {
    i = 0;
    di ::= i + 1;

    loop {
        if i >= D {
            break;
        }

        j = 0;
        dj ::= j + 1;

        loop {
            if j >= D[i] {
                break;
            }

            println D[i][j];
            j = dj;
        }

        i = di;
    }
}

# ---- demo ---- #

P = allocvecarrays(3);
initvectors(P);

A = P.A;
B = P.B;

D = allocmatrix(A, B);
binddots(D, A, B);

# ---- initial matrix ---- #
printmatrix(D);

# ---- mutate vectors ---- #
A[1].x = 100;
B[2].y = 1;
println ' ';

# ---- matrix updates automatically ---- #
printmatrix(D);
