#
=========================================
Reactive Queue
=========================================

Fixed-capacity FIFO queue implementation
with reactive-derived properties.

Characteristics:
- Uses a circular buffer
- Fixed capacity (no resizing)
- FIFO (first-in, first-out)
- Safe for reactive (::=) expressions

Stored values are integers.
Indices and counters are integers.

Import with:
import std.queue;

=========================================
#

#
-----------------------------------------
Queue structure
-----------------------------------------
Fields:
data  : backing array
cap   : maximum capacity

head  : index of next element to read
tail  : index of next element to write
count : number of stored elements

Reactive fields:
size  ::= count
empty ::= count == 0
full  ::= count == cap
-----------------------------------------
#
struct Queue {
    data;
    cap = 0;

    head = 0;
    tail = 0;
    count = 0;

    size ::= count;
    empty ::= count == 0;
    full ::= count == cap;
}

#
-----------------------------------------
queue
-----------------------------------------
Create a new empty queue with a fixed
capacity.

Args:
capacity : maximum number of elements

Returns:
initialized Queue instance
-----------------------------------------
#
func queue(capacity) {
    q := struct Queue;
    q.data = [capacity];
    q.cap = capacity;

    q.head = 0;
    q.tail = 0;
    q.count = 0;

    return q;
}

#
-----------------------------------------
enqueue
-----------------------------------------
Add a value to the back of the queue.

If the queue is full, the operation
fails and no state is modified.

Args:
q     : Queue
value : integer to enqueue

Returns:
value if successful
0 if the queue is full
-----------------------------------------
#
func enqueue(q, value) {
    if q.count >= q.cap {
        return 0;
    }

    q.data[q.tail] = value;
    q.tail = (q.tail + 1) % q.cap;
    q.count = q.count + 1;

    return value;
}

#
-----------------------------------------
dequeue
-----------------------------------------
Remove and return the front element of
the queue.

If the queue is empty, the operation
fails and no state is modified.

Args:
q : Queue

Returns:
dequeued value
0 if the queue is empty
-----------------------------------------
#
func dequeue(q) {
    if q.count == 0 {
        return 0;
    }

    v := q.data[q.head];
    q.head = (q.head + 1) % q.cap;
    q.count = q.count - 1;

    return v;
}

#
-----------------------------------------
peek
-----------------------------------------
Read the front element without removing
it from the queue.

Args:
q : Queue

Returns:
front value
0 if the queue is empty
-----------------------------------------
#
func peek(q) {
    if q.count == 0 {
        return 0;
    }

    return q.data[q.head];
}
