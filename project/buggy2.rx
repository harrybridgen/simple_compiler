struct Matrix {
    data := [4];
}

func build_matrix() {
    M := struct Matrix

    x = 0;
    di ::= x + 1;
    loop {
        if x >= 4 { break; }
        M.data[x] = x + 1;   
        x = di;
    }
    return M;
}

func add_matrix(a, b) {
    M := struct Matrix

    i = 0;
    di ::= i + 1;

    loop {
        if i >= 4 { break; }
        ii := i;  
        M.data[ii] ::= a.data[ii] + b.data[ii];
        i = di;
    }
    return M;
}

func print_matrix(M){
    i = 0;
    di ::= i + 1;

    loop {
        if i >= 4 { break; }
        println M.data[i];
        i = di;
    }
}

# ================= DEMO ================= #

A = build_matrix();
B = build_matrix();
C ::= add_matrix(A, B);
print_matrix(C);

A.data[0] = 10;

print_matrix(C);

#
Current semantics (important):

Reactive bindings (::=) are evaluated later and currently behave like
GLOBAL closures only.

They may safely reference:
- global variables (A, B, etc.)
- struct fields injected into reactive scope (x, y, len, etc.)
- numeric / char literals

They may NOT reference:
- function parameters (a, b)
- local variables (i)
- values captured via := (aa := a, ii := i)

Why this breaks:
- ::= stores only an AST
- when re-evaluated, the function scope is gone
- parameters and locals no longer exist
- lookup fails -> unbound variable / unwrap(None)

Why the "A.data[ii] + B.data[ii]" hack works:
- A and B are globals
- ii is frozen with :=
- no function-local names are required at eval time

What NOT to do:
- Do NOT make params behave like :=
  (this lies about lifetimes and breaks later)

Correct fix:
- Implement reactive closures
- Store captures inside LazyValue at ::= creation time
- Capture free variables (params, locals, structs, arrays)
- Inject captures into immutable scope during evaluation

Once done:
- params work in ::=
- locals work in ::=
- matrix addition works correctly
- mental model matches runtime behavior
#
